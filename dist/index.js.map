{"version":3,"sources":["../src/logger/formatters.ts","../src/logger/colors.ts","../src/logger/emitter.ts","../src/types/log_threshold.ts","../src/logger/level_priority.ts","../src/logger/log_core.ts","../src/logger/loggers.ts"],"sourcesContent":["import { inspect } from \"node:util\";\nimport type { Formatter, FormatterConfig } from \"../types/formatter.js\";\nimport { getColorFor, RESET_COLOR } from \"./colors.js\";\n\n/**\n * Formats a log message with no colors.\n * Adds a prefix (with optional timestamp), followed by the joined message body.\n *\n * Example output:\n * `[INFO] message here`\n * or\n * `2025-05-10T12:34:56.789Z [INFO] message here`\n */\nexport const plainFormatter: Formatter = (config) => {\n\tconst prefix = getPrefix(config);\n\tconst body = config.args.map(formatArg).join(\" \");\n\treturn body ? `${prefix} ${body}` : prefix;\n};\n\n/**\n * Formats a log message with ANSI colors based on log level.\n * Adds a prefix (with optional timestamp), wraps it in color codes.\n *\n * Example output:\n * `\\x1b[33m[WARN] something happened\\x1b[0m`\n */\nexport const colorFormatter: Formatter = (config) => {\n\tconst color = getColorFor(config.level);\n\tconst prefix = getPrefix(config);\n\tconst body = config.args.map(formatArg).join(\" \");\n\tconst line = body ? `${prefix} ${body}` : prefix;\n\treturn `${color}${line}${RESET_COLOR}`;\n};\n\n/**\n * Formats various data types to be printed\n *\n * @param arg - Argument to format\n * @returns String ready to be printed\n */\nexport function formatArg(arg: unknown): string {\n\tif (typeof arg === \"undefined\") return \"undefined\";\n\tif (arg instanceof Error)\n\t\treturn `${arg.name}: ${arg.message}\\n${arg.stack ?? \"\"}`;\n\tif (typeof arg === \"string\") return arg;\n\tif (typeof arg === \"bigint\") return `${arg}n`;\n\tif (typeof arg === \"function\")\n\t\treturn `[Function ${(arg).name || \"anonymous\"}]`;\n\n\tif (typeof arg === \"object\" && arg !== null) {\n\t\ttry {\n\t\t\treturn JSON.stringify(arg, jsonReplacer);\n\t\t} catch {\n\t\t\ttry {\n\t\t\t\treturn inspect(arg, { depth: null, breakLength: Infinity });\n\t\t\t} catch {\n\t\t\t\treturn \"[Unserializable Object]\";\n\t\t\t}\n\t\t}\n\t}\n\treturn String(arg);\n}\n\n/**\n * Builds the log prefix for a given message.\n * If a custom `prefixBuilder` is provided in the config, it's used directly.\n * Otherwise, constructs `[LEVEL]` or `timestamp [LEVEL]` depending on config.\n *\n * @param config - Formatter config including log level and optional timestamp/custom builder.\n * @returns A formatted prefix string.\n */\nexport function getPrefix({\n\tlevel,\n\tprefixBuilder,\n\twithTimestamp = false,\n}: FormatterConfig): string {\n\tif (typeof prefixBuilder === \"function\") {\n\t\treturn prefixBuilder();\n\t}\n\n\tconst timestamp = withTimestamp ? `${new Date().toISOString()} ` : \"\";\n\n\treturn `${timestamp}[${level.toUpperCase()}]`;\n}\n\nfunction jsonReplacer(_k: string, v: unknown) {\n\tif (typeof v === \"bigint\") return String(v);\n\tif (typeof v === \"symbol\") return v.toString();\n\tif (v instanceof Map) return Object.fromEntries(v);\n\tif (v instanceof Set) return Array.from(v);\n\treturn v;\n}\n","import type { LogLevel } from \"../types/log_level.js\";\n\n/**\n * ANSI color codes mapped to log levels for terminal output.\n * These control how the log prefix is rendered in supported terminals.\n */\nconst LEVEL_COLORS = Object.freeze({\n\tdebug: \"\\x1b[90m\", // gray\n\tinfo: \"\\x1b[36m\", // cyan\n\twarn: \"\\x1b[33m\", // yellow/orange\n\terror: \"\\x1b[31m\", // red\n} as const satisfies Record<LogLevel, string>);\n\nexport const RESET_COLOR = \"\\x1b[0m\";\n\n/**\n * Returns the ANSI color code for a given log level.\n * Throws if the level is unknown or not configured.\n *\n * @param level - The log level to get color for.\n * @returns ANSI escape code string for that level.\n */\nexport function getColorFor(level: LogLevel): string {\n\tif (!Object.hasOwn(LEVEL_COLORS, level)) {\n\t\tthrow new Error(`Unknown log level: \"${level}\"`);\n\t}\n\n\treturn LEVEL_COLORS[level];\n}\n","import type { ConsoleMethod } from \"../types/console_method.js\";\nimport type { LogLevel } from \"../types/log_level.js\";\n\n/**\n * Maps each log level to the corresponding console method.\n * Used internally to dispatch messages to the correct output function.\n */\nconst CONSOLE_METHODS = Object.freeze({\n\tdebug: \"log\",\n\tinfo: \"info\",\n\twarn: \"warn\",\n\terror: \"error\",\n} as const satisfies Record<LogLevel, ConsoleMethod>);\n\n/**\n * Returns console method to use for a given log level.\n * Throws if the level is unknown or not configured.\n *\n * @param level - The log level to get method for.\n * @returns ConsoleMethod\n */\nfunction getMethodFor(level: LogLevel): ConsoleMethod {\n\tconst m = CONSOLE_METHODS[level];\n\tif (!m) throw new Error(`Unknown method for level: \"${level}\"`);\n\treturn m;\n}\n\n/**\n * Emits a log message to the appropriate console method.\n * Assumes message is already formatted and ready to print.\n *\n * @param level - The log level of the message (e.g. \"warn\", \"error\")\n * @param message - The final string to output (includes prefix, colors, etc.)\n */\nexport function emitLog(level: LogLevel, message: string): void {\n\tconst method = getMethodFor(level);\n\tconst fn = console[method] as (msg?: unknown, ...rest: unknown[]) => void;\n\tfn(message);\n}\n","export const logThresholds = [\n\t\"debug\",\n\t\"info\",\n\t\"warn\",\n\t\"error\",\n\t\"silent\",\n] as const;\nexport type LogThreshold = (typeof logThresholds)[number];\n","import type { LogLevel } from \"../types/log_level.js\";\nimport { type LogThreshold, logThresholds } from \"../types/log_threshold.js\";\n\nfunction fromEntriesStrict<K extends PropertyKey, V>(\n\tentries: readonly (readonly [K, V])[],\n): Record<K, V> {\n\treturn Object.fromEntries(entries) as Record<K, V>;\n}\n\n/**\n * Assigns a numeric priority to each log threshold level.\n * Lower numbers mean more verbose; higher means more critical.\n * \"silent\" is given a very high value to suppress all output.\n */\nexport const levelPriority = fromEntriesStrict(\n\tlogThresholds.map(\n\t\t(level, index) =>\n\t\t\t[level, level === \"silent\" ? Number.POSITIVE_INFINITY : index] as const,\n\t),\n) satisfies Record<LogThreshold, number>;\n\n/**\n * Returns the numeric priority for a given log level or threshold.\n * Throws if the level is unknown or not registered.\n *\n * @param level - Log level or threshold\n * @returns Priority number\n */\nexport function getPriorityFor(level: LogLevel | LogThreshold): number {\n\tconst p = levelPriority[level as LogThreshold];\n\tif (p === undefined)\n\t\tthrow new Error(`Unknown log level/threshold: \"${level}\"`);\n\treturn p;\n}\n\n/**\n * Determines whether a message with the given `level` should be logged\n * based on the user-defined `threshold`.\n *\n * @param threshold - The minimum log level required to allow output\n * @param level - The log level of the current message\n * @returns `true` if the message should be printed, `false` otherwise\n */\nexport function shouldLog(threshold: LogThreshold, level: LogLevel): boolean {\n\treturn getPriorityFor(level) >= getPriorityFor(threshold);\n}\n","import type { Formatter } from \"../types/formatter.js\";\nimport type { LogParams } from \"../types/log_params.js\";\nimport { emitLog } from \"./emitter.js\";\nimport { shouldLog } from \"./level_priority.js\";\n\n/**\n * Core logging function that handles level filtering, formatting, and emitting.\n *\n * - Skips logging if `shouldLog(threshold, level)` returns false.\n * - Uses the provided `formatter` to convert log args to a string.\n * - Passes the final message to `emitLog`.\n *\n * @param params - Log configuration: level, threshold, and optional timestamp.\n * @param formatter - Function that formats the log message.\n * @param args - Arbitrary message arguments to be logged.\n */\nexport function logCore(\n\tparams: LogParams,\n\tformatter: Formatter,\n\t...args: unknown[]\n): void {\n\tconst {\n\t\tlevel,\n\t\tprefixBuilder,\n\t\tthreshold = \"info\",\n\t\twithTimestamp = false,\n\t} = params;\n\n\tif (!shouldLog(threshold, level)) return;\n\n\ttry {\n\t\tconst msg = formatter({\n\t\t\tlevel,\n\t\t\targs,\n\t\t\twithTimestamp,\n\t\t\t...(prefixBuilder ? { prefixBuilder } : {}),\n\t\t});\n\t\temitLog(level, msg);\n\t} catch (err) {\n\t\ttry {\n\t\t\tconst fallback =\n\t\t\t\t`[logging-error @ ${new Date().toISOString()}] ` +\n\t\t\t\t(err instanceof Error ? `${err.name}: ${err.message}` : String(err));\n\t\t\tconsole.error(fallback);\n\t\t} catch {}\n\t}\n}\n","import type { Formatter } from \"../types/formatter.js\";\nimport type { LogFunction } from \"../types/log_function.js\";\nimport type { LogParams } from \"../types/log_params.js\";\nimport { colorFormatter, plainFormatter } from \"./formatters.js\";\nimport { logCore } from \"./log_core.js\";\n\n/**\n * Default parameters used when the caller omits an explicit\n * `LogParams` object ( a \"fire-and-forget\" call).\n */\nconst DEFAULT_LOG_PARAMS = Object.freeze({\n\tlevel: \"info\",\n\tthreshold: \"info\",\n} as const satisfies LogParams);\n\nexport const createLogger = (formatter: Formatter): LogFunction => {\n\treturn (first: LogParams | unknown, ...rest: unknown[]): void => {\n\t\tconst provided = isLogParams(first) ? first : undefined;\n\t\tconst params: LogParams = { ...DEFAULT_LOG_PARAMS, ...provided };\n\t\tconst args = provided ? rest : [first, ...rest];\n\t\tlogCore(params, formatter, ...args);\n\t};\n};\n\n/**\n * Log with colourised output.\n * **Overloads**\n * 1. `(message, ...rest)` – uses sensible defaults (`info`/`info`).\n * 2. `(params, message, ...rest)` – full control.\n */\nexport const logWithColor: LogFunction = createLogger(colorFormatter);\n\n/**\n * Log without colours – plain prefix only.\n * **Overloads**\n * 1. `(message, ...rest)` – defaults to `info` level.\n * 2. `(params, message, ...rest)` – caller supplies `LogParams`.\n */\nexport const logWithLevel: LogFunction = createLogger(plainFormatter);\n\n/**\n * Runtime guard that checks whether an arbitrary value is a `LogParams` bag.\n * (Deliberately not exhaustive – we only need to know core keys.)\n */\nfunction isLogParams(obj: unknown): obj is LogParams {\n\tif (typeof obj !== \"object\" || obj === null) return false;\n\tconst o = obj as Record<string, unknown>;\n\n\tif (typeof o.level !== \"string\") return false;\n\n\tif (\n\t\t\"threshold\" in o &&\n\t\to.threshold !== undefined &&\n\t\ttypeof o.threshold !== \"string\"\n\t)\n\t\treturn false;\n\tif (\n\t\t\"withTimestamp\" in o &&\n\t\to.withTimestamp !== undefined &&\n\t\ttypeof o.withTimestamp !== \"boolean\"\n\t)\n\t\treturn false;\n\tif (\n\t\t\"prefixBuilder\" in o &&\n\t\to.prefixBuilder !== undefined &&\n\t\ttypeof o.prefixBuilder !== \"function\"\n\t)\n\t\treturn false;\n\n\treturn true;\n}\n"],"mappings":"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","names":[]}