{"version":3,"sources":["../src/logger/colors.ts","../src/logger/formatters.ts","../src/logger/emitter.ts","../src/types/log_threshold.ts","../src/logger/level_priority.ts","../src/logger/log_core.ts","../src/logger/loggers.ts"],"sourcesContent":["import type { LogLevel } from \"../types/log_level.js\";\n\nexport const RESET_COLOR = \"\\x1b[0m\";\n\n/**\n * Returns the ANSI color code for a given log level.\n * Throws if the level is unknown or not configured.\n *\n * @param level - The log level to get color for.\n * @returns ANSI escape code string for that level.\n */\nexport function getColorFor(level: LogLevel): string {\n\tif (!(level in LEVEL_COLORS)) {\n\t\tthrow new Error(`Unknown log level: \"${level}\"`);\n\t}\n\n\treturn LEVEL_COLORS[level];\n}\n\n/**\n * ANSI color codes mapped to log levels for terminal output.\n * These control how the log prefix is rendered in supported terminals.\n */\nconst LEVEL_COLORS: Record<LogLevel, string> = {\n\tdebug: \"\\x1b[90m\", // gray\n\tinfo: \"\\x1b[36m\", // cyan\n\twarn: \"\\x1b[33m\", // yellow/orange\n\terror: \"\\x1b[31m\", // red\n};\n","import type { Formatter, FormatterConfig } from \"../types/formatter.js\";\nimport { RESET_COLOR, getColorFor } from \"./colors.js\";\n\n/**\n * Formats a log message with no colors.\n * Adds a prefix (with optional timestamp), followed by the joined message body.\n *\n * Example output:\n * `[INFO] message here`\n * or\n * `2025-05-10T12:34:56.789Z [INFO] message here`\n */\nexport const plainFormatter: Formatter = (config) => {\n\tconst prefix = getPrefix(config);\n\tconst body = config.args.map(formatArg).join(\" \");\n\n\treturn `${prefix} ${body}`;\n};\n\n/**\n * Formats a log message with ANSI colors based on log level.\n * Adds a prefix (with optional timestamp), wraps it in color codes.\n *\n * Example output:\n * `\\x1b[33m[WARN] something happened\\x1b[0m`\n */\nexport const colorFormatter: Formatter = (config) => {\n\tconst color = getColorFor(config.level);\n\tconst prefix = getPrefix(config);\n\tconst body = config.args.map(formatArg).join(\" \");\n\n\treturn `${color}${prefix} ${body}${RESET_COLOR}`;\n};\n\n/**\n * Formats various data types to be printed\n *\n * @param arg - Argument to format\n * @returns String ready to be printed\n */\nfunction formatArg(arg: unknown): string {\n\tif (arg instanceof Error) {\n\t\treturn `${arg.name}: ${arg.message}\\n${arg.stack ?? \"\"}`;\n\t}\n\n\tif (typeof arg === \"object\" && arg !== null) {\n\t\ttry {\n\t\t\treturn JSON.stringify(arg);\n\t\t} catch {\n\t\t\treturn \"[Unserializable Object]\";\n\t\t}\n\t}\n\n\treturn String(arg);\n}\n\n/**\n * Builds the log prefix for a given message.\n * If a custom `prefixBuilder` is provided in the config, it's used directly.\n * Otherwise, constructs `[LEVEL]` or `timestamp [LEVEL]` depending on config.\n *\n * @param config - Formatter config including log level and optional timestamp/custom builder.\n * @returns A formatted prefix string.\n */\nexport function getPrefix({\n\tlevel,\n\tprefixBuilder,\n\twithTimestamp = false,\n}: FormatterConfig): string {\n\tif (typeof prefixBuilder === \"function\") {\n\t\treturn prefixBuilder();\n\t}\n\n\tconst timestamp = withTimestamp ? `${new Date().toISOString()} ` : \"\";\n\n\treturn `${timestamp}[${level.toUpperCase()}]`;\n}\n","import type { ConsoleMethod } from \"../types/console_method.js\";\nimport type { LogLevel } from \"../types/log_level.js\";\n\n/**\n * Emits a log message to the appropriate console method.\n * Assumes message is already formatted and ready to print.\n *\n * @param level - The log level of the message (e.g. \"warn\", \"error\")\n * @param message - The final string to output (includes prefix, colors, etc.)\n */\nexport function emitLog(level: LogLevel, message: string): void {\n\tconst method = getMethodFor(level);\n\n\tconsole[method](message);\n}\n\n/**\n * Returns console method to use for a given log level.\n * Throws if the level is unknown or not configured.\n *\n * @param level - The log level to get color for.\n * @returns ConsoleMethod\n */\nfunction getMethodFor(level: LogLevel): ConsoleMethod {\n\tif (!(level in CONSOLE_METHODS)) {\n\t\tthrow new Error(`Unknown method for level: \"${level}\"`);\n\t}\n\n\treturn CONSOLE_METHODS[level];\n}\n\n/**\n * Maps each log level to the corresponding console method.\n * Used internally to dispatch messages to the correct output function.\n */\nconst CONSOLE_METHODS: Record<LogLevel, ConsoleMethod> = {\n\tdebug: \"log\",\n\tinfo: \"info\",\n\twarn: \"warn\",\n\terror: \"error\",\n};\n","export const logThresholds = [\n\t\"debug\",\n\t\"info\",\n\t\"warn\",\n\t\"error\",\n\t\"silent\",\n] as const;\nexport type LogThreshold = (typeof logThresholds)[number];\n","import type { LogLevel } from \"../types/log_level.js\";\nimport { type LogThreshold, logThresholds } from \"../types/log_threshold.js\";\n\n/**\n * Assigns a numeric priority to each log threshold level.\n * Lower numbers mean more verbose; higher means more critical.\n * \"silent\" is given a very high value (999) to suppress all output.\n */\nexport const levelPriority: Record<LogThreshold, number> = Object.fromEntries(\n\tlogThresholds.map((level, index) =>\n\t\tlevel === \"silent\" ? [level, 999] : [level, index],\n\t),\n) as Record<LogThreshold, number>;\n\n/**\n * Determines whether a message with the given `level` should be logged\n * based on the user-defined `threshold`.\n *\n * @param threshold - The minimum log level required to allow output\n * @param level - The log level of the current message\n * @returns `true` if the message should be printed, `false` otherwise\n */\nexport function shouldLog(threshold: LogThreshold, level: LogLevel): boolean {\n\treturn levelPriority[level] >= levelPriority[threshold];\n}\n","import type { Formatter } from \"../types/formatter.js\";\nimport type { LogParams } from \"../types/log_params.js\";\nimport { emitLog } from \"./emitter.js\";\nimport { shouldLog } from \"./level_priority.js\";\n\n/**\n * Core logging function that handles level filtering, formatting, and emitting.\n *\n * - Skips logging if `shouldLog(threshold, level)` returns false.\n * - Uses the provided `formatter` to convert log args to a string.\n * - Passes the final message to `emitLog`.\n *\n * @param params - Log configuration: level, threshold, and optional timestamp.\n * @param formatter - Function that formats the log message.\n * @param args - Arbitrary message arguments to be logged.\n */\nexport function logCore(\n\tparams: LogParams,\n\tformatter: Formatter,\n\t...args: unknown[]\n): void {\n\tconst {\n\t\tlevel,\n\t\tprefixBuilder,\n\t\tthreshold = \"info\",\n\t\twithTimestamp = false,\n\t} = params;\n\n\tif (!shouldLog(threshold, level)) return;\n\n\tconst msg = formatter({ level, args, prefixBuilder, withTimestamp });\n\temitLog(level, msg);\n}\n","import type { LogParams } from \"../types/log_params.js\";\nimport { colorFormatter, plainFormatter } from \"./formatters.js\";\nimport { logCore } from \"./log_core.js\";\n\n/**\n * Default parameters used when the caller omits an explicit\n * `LogParams` object ( a “fire-and-forget” call).\n */\nconst DEFAULT_LOG_PARAMS: LogParams = {\n\tlevel: \"info\",\n\tthreshold: \"info\",\n};\n\n/**\n * Log with colourised output.\n * **Overloads**\n * 1. `(message, ...rest)` – uses sensible defaults (`info`/`info`).\n * 2. `(params, message, ...rest)` – full control.\n */\nexport function logWithColor(...args: unknown[]): void;\nexport function logWithColor(params: LogParams, ...args: unknown[]): void;\n\nexport function logWithColor(\n\tfirst: LogParams | unknown,\n\t...rest: unknown[]\n): void {\n\tconst formatter = colorFormatter;\n\n\tif (isLogParams(first)) {\n\t\tlogCore(first, formatter, ...rest);\n\t} else {\n\t\tlogCore(DEFAULT_LOG_PARAMS, formatter, first, ...rest);\n\t}\n}\n\n/**\n * Log without colours – plain prefix only.\n * **Overloads**\n * 1. `(message, ...rest)` – defaults to `info` level.\n * 2. `(params, message, ...rest)` – caller supplies `LogParams`.\n */\nexport function logWithLevel(...args: unknown[]): void;\nexport function logWithLevel(params: LogParams, ...args: unknown[]): void;\n\nexport function logWithLevel(\n\tfirst: LogParams | unknown,\n\t...rest: unknown[]\n): void {\n\tconst formatter = plainFormatter;\n\n\tif (isLogParams(first)) {\n\t\tlogCore(first, formatter, ...rest);\n\t} else {\n\t\tlogCore(DEFAULT_LOG_PARAMS, formatter, first, ...rest);\n\t}\n}\n\n/**\n * Runtime guard that checks whether an arbitrary value is a `LogParams` bag.\n * (Deliberately not exhaustive – we only need to know core keys.)\n */\nfunction isLogParams(obj: unknown): obj is LogParams {\n\treturn (\n\t\ttypeof obj === \"object\" &&\n\t\tobj !== null &&\n\t\t\"level\" in obj &&\n\t\ttypeof obj.level === \"string\"\n\t);\n}\n"],"mappings":"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","names":[]}